---
- name: "Using BIG-IQ: Generate backup/ucs of group based on existing schedule; Deploy UCS to BIG-IPs"
  hosts: bigiq
  #connection: local
  gather_facts: no

  collections:
    - f5networks.f5_modules

  vars:
    user: admin
    password: purple123
    existingBackupName: daily-backup2
    backupDict: {}
    targetLinkDevices: {}
    targetDevices: {}
    targetDeviceswFile: {}
    filesToTransfer: []
    #dateTimeDeployment: "{{ lookup('pipe', 'date \"+%Y%m%d%H%M\"') }}"
   

  # vars_prompt:
  #   - name: password
  #     prompt: "Enter Password"
  #     private: no

  #   - name: existingBackupName
  #     prompt: "Copy and paste your existing scheduled Backup name here"
  #     private: no

  #   - name: bigipIP
  #     prompt: "Input IP of BIGIP"
  #     private: no

  tasks:
  - name: Creating an empty file
    file:
      path: "../vars/play_vars.yml"
      state: touch
    delegate_to: localhost
    
  - name: print
    debug:
      msg: "{{item | basename}}"
    loop: "{{ lookup('fileglob', '../ucs/*', wantlist=True) }}"

  - name: Get timestamp from the system
    shell: "date +%Y%m%d%H%M"
    register: day_time

  - name: set day & time var
    set_fact: 
      day_time: "{{day_time.stdout}}"

  - name: print day & time var
    debug:
      msg: "{{day_time}}"

  - name: set name of deployment
    set_fact:
      nameOfDeployment: "ansibleDeploy_{{day_time}}"
      
  - name: GET - list of scheduled backups
    uri:
      url: "https://{{inventory_hostname}}/mgmt/shared/task-scheduler/scheduler/"
      method: GET
      user: "{{user}}"
      password: "{{password}}"
      validate_certs: no
    delegate_to: localhost
    register: scheduledBackups

  - name: Print result of get for scheduled backups
    debug:
      msg: "{{scheduledBackups}}"
      verbosity: 1

  - name: Set_fact - create dict of scheduled backup values
    set_fact: 
      backupDict: "{{ scheduledBackups | json_query(query_json) }}"
    vars:
      query_json: >
        {"devicesReference": json.items[?name=='{{existingBackupName}}'].taskBodyToRun.devicesReference, "taskReference": json.items[?name=='{{existingBackupName}}'].taskBodyToRun.taskReference, "taskBody": {"namePrefix": '{{nameOfDeployment}}_', "includePrivateKeys": json.items[?name=='{{existingBackupName}}'].taskBodyToRun.taskBody.includePrivateKeys, "isEncrypted": json.items[?name=='{{existingBackupName}}'].taskBodyToRun.taskBody.isEncrypted, "backupLifeTime": '1', "shouldCreateArchive": 'false', "name": '{{nameOfDeployment}}.ucs', "selfLink": json.items[?name=='{{existingBackupName}}'].selfLink, "obfuscatedPassphrase": json.items[?name=='{{existingBackupName}}'].taskBodyToRun.taskBody.obfuscatedPassphrase}}

  - name: Print dict of backup values
    debug:
      msg: "{{ backupDict }}"
      #verbosity: 1


######  Initiating UCS backup now ######

  - name: POST - to initiate backup encrypted
    uri:
      url: "https://{{inventory_hostname}}/mgmt/shared/group-task"
      method: POST
      user: "{{user}}"
      password: "{{password}}"
      validate_certs: no
      status_code: 202
      body: 
        devicesReference: "{{backupDict.devicesReference[0]}}"
        taskReference: "{{backupDict.taskReference[0]}}"
        taskBody:
          namePrefix: "{{backupDict.taskBody.namePrefix}}"
          includePrivateKeys: "{{backupDict.taskBody.includePrivateKeys[0]}}"
          isEncrypted: "{{backupDict.taskBody.isEncrypted[0]}}"
          backupLifeTime: "{{backupDict.taskBody.backupLifeTime}}"
          shouldCreateArchive: "{{backupDict.taskBody.shouldCreateArchive}}"
          name: "{{backupDict.taskBody.name}}"
          selfLink: "{{backupDict.taskBody.selfLink[0]}}"
          obfuscatedPassphrase: "{{backupDict.taskBody.obfuscatedPassphrase[0]}}"
      body_format: json
    delegate_to: localhost
    register: resultInitiateBackup
    when: backupDict.taskBody.obfuscatedPassphrase[0] is defined

  - name: print results of initiating backup
    debug:  
      msg: "{{ resultInitiateBackup }}"
      #verbosity: 1

  - name: Set_fact - get task ID
    set_fact: 
      taskID: "{{ resultInitiateBackup | json_query(query_json) }}"
    vars:
      query_json: >
        json.id

  - name: print results of taskID
    debug:  
      msg: "{{ taskID }}"
      #verbosity: 1

  - name: GET - to check status of backup, waiting for FINISHED
    uri:
      url: "https://{{inventory_hostname}}/mgmt/shared/group-task/{{taskID}}"
      method: GET
      user: "{{user}}"
      password: "{{password}}"
      validate_certs: no
    delegate_to: localhost
    register: statusOfBackup
    until: statusOfBackup.json.status.find("FINISHED") != -1
    retries: 45
    delay: 20

  - name: print results of status check of backup
    debug:  
      msg: "{{ statusOfBackup }}"
      #verbosity: 1

####### testing below #############
  # - name: delete after testing
  #   set_fact:
  #     statusOfBackup: 
  #       {
  #               "attempts": 15,
  #               "cache_control": "no-store, no-cache, must-revalidate",
  #               "changed": false,
  #               "connection": "close",
  #               "content_length": "1422",
  #               "content_type": "application/json; charset=UTF-8",
  #               "cookies": {},
  #               "cookies_string": "",
  #               "date": "Tue, 02 Mar 2021 19:52:40 GMT",
  #               "elapsed": 0,
  #               "expires": "-1",
  #               "failed": false,
  #               "json": {
  #                   "continueOnError": false,
  #                   "devicesReference": {
  #                       "link": "https://localhost/mgmt/shared/resolver/device-groups/Boston/devices?$filter='product'+eq+'BIG-IP'"
  #                   },
  #                   "endDateTime": "2021-03-02T11:52:34.291-0800",
  #                   "generation": 7,
  #                   "id": "90a6d201-95e7-42e1-9a7e-6fdf8f59c57b",
  #                   "identityReferences": [
  #                       {
  #                           "link": "https://localhost/mgmt/shared/authz/users/admin"
  #                       }
  #                   ],
  #                   "kind": "shared:group-task:devicegrouptaskitemstate",
  #                   "lastUpdateMicros": 1614714754292774,
  #                   "ownerMachineId": "e8b6a888-24e4-426c-8088-542f69f6f78d",
  #                   "progress": "Waiting for tasks to complete.",
  #                   "selfLink": "https://localhost/mgmt/shared/group-task/90a6d201-95e7-42e1-9a7e-6fdf8f59c57b",
  #                   "startedTaskReferences": [
  #                       {
  #                           "link": "https://localhost/mgmt/cm/system/backup-restore/6d67b746-fa9b-4609-9672-9a1180672fc9"
  #                       },
  #                       {
  #                           "link": "https://localhost/mgmt/cm/system/backup-restore/b3efbc8c-1493-4a38-b24b-21c016b211b7"
  #                       }
  #                   ],
  #                   "status": "FINISHED",
  #                   "step": "WAIT_FOR_DEVICE_TASKS",
  #                   "taskBody": {
  #                       "backupLifeTime": "1",
  #                       "includePrivateKeys": true,
  #                       "isEncrypted": true,
  #                       "name": "ansibleDeploy_202103021147.ucs",
  #                       "namePrefix": "ansibleDeploy_202103021147_",
  #                       "obfuscatedPassphrase": "Da/Ggn0mNw7nFIWcR8Z1JvwpRbe8o4t9Hdi0Xcr8qPw=",
  #                       "selfLink": "https://localhost/mgmt/shared/task-scheduler/scheduler/fefc2b35-6f3b-3c5b-a520-6ff9594948f3",
  #                       "shouldCreateArchive": "false"
  #                   },
  #                   "taskReference": {
  #                       "link": "http://localhost:8100/cm/system/backup-restore"
  #                   },
  #                   "timeoutSeconds": 0,
  #                   "userReference": {
  #                       "link": "https://localhost/mgmt/shared/authz/users/admin"
  #                   }
  #               },
  #               "msg": "OK (1422 bytes)",
  #               "pragma": "no-cache",
  #               "redirected": false,
  #               "server": "webd",
  #               "status": 200,
  #               "url": "https://ip-10-1-1-4.us-west-2.compute.internal/mgmt/shared/group-task/90a6d201-95e7-42e1-9a7e-6fdf8f59c57b"
  #           }

  - name: Set_fact - set variable to number of devices
    set_fact:
      numOfDevices: "{{ statusOfBackup | json_query('json.startedTaskReferences[].link | length(@)') }}"

  - name: Set_fact - create dict links for devices
    set_fact: 
      targetLinkDevices: "{{  targetLinkDevices | combine({item: statusOfBackup | json_query(query_json) |  urlsplit('path')}) }}"
    vars:
      query_json: >
        json.startedTaskReferences[{{item}}].link
    loop: "{{ range(0, (numOfDevices | int)) |list }}"

  - name: GET - list of devices for backup to create dictionary
    uri:
      url: "https://{{inventory_hostname}}{{item.value}}"
      method: GET
      user: "{{user}}"
      password: "{{password}}"
      validate_certs: no
    delegate_to: localhost
    register: devicesToBeBackedup
    loop: "{{ targetLinkDevices | dict2items }}"
  
  - name: Print results of device targets
    debug:
      msg: "{{ devicesToBeBackedup }}"
      #verbosity: 1

  - name: Set_fact - create dict of devices to be updated
    set_fact: 
      targetDevices: "{{  targetDevices | combine({item: devicesToBeBackedup | json_query(query_json)}) }}"
    vars:
      query_json: >
        {"device": results[{{item}}].json.device.hostname, "address": results[{{item}}].json.device.address, "machineId": results[{{item}}].json.device.machineId, fileName: results[{{item}}].json.name}
    loop: "{{ range(0, (numOfDevices | int)) |list }}"

  - name: Print results of device dictionary
    debug:
      msg: "{{ targetDevices }}"
      #verbosity: 1



######  BELOW IS TO DOWNLOAD RECENTLY CREATED UCS #####

  - name: find ucs files that were created
    find:
      paths: /shared/ucs_backups/
      patterns: '{{nameOfDeployment}}.*'
      use_regex: yes
    register: findFiles
  
  - name: print findFiles
    debug:
      msg: "{{findFiles}}"
      verbosity: 1

  - name: set file names to transfer
    set_fact:
      findFiles: "{{ findFiles | json_query(query_json) }}"
    vars:
      query_json: >
        files[].path
  
  - name: print findFiles
    debug:
      msg: "{{findFiles}}"

  - name: filter path to get name of file 
    set_fact:
      filesToTransfer: "{{ filesToTransfer + [item | basename] }}"
    with_items: "{{ findFiles }}"
  
  - name: print filesToTransfer
    debug:
      msg: "{{filesToTransfer}}"
      verbosity: 1
  
  - name: Get the ucs files that were just created
    fetch:
      src: /shared/ucs_backups/{{item}}
      dest: ../ucs/
      flat: yes
    with_items: "{{ filesToTransfer }}"

  - name: print
    debug:
      msg: "{{item | basename}}"
    loop: "{{ lookup('fileglob', '../ucs/*', wantlist=True) }}"

  - name: get files in /ucs
    set_fact:
      files: "{{ lookup('fileglob', '../ucs/*', wantlist=True) }}"
  
  - name: filter
    debug:
      msg: "{{ files | select('match', 'targetDevices.0.device') | list }}"

  - name: Set_fact - add device specific ucs to device dictionary
    set_fact: 
      targetDevices: "{{ targetDevices | combine({item.key: {'file': (files[my_idx] | basename)}}, recursive=true) }}"  
    with_dict: "{{targetDevices}}"
    loop_control:
      index_var: my_idx
  
  - name: print
    debug:
      msg: "{{targetDevices}}"
      #verbosity: 1


######  PAUSE TO ALLOW FOR RE-PAVE ACTIVITIES #####

  - name: Do you want to continue
    debug:
      msg: "The playbook will pause while a re-pave effort is completed. Please follow the PAUSE instructions. -tmsh load sys config default -Reboot -set Password"
    tags:
      - always

  - name: pause for 7200 seconds
    pause:
      seconds: 7200
    tags:
      - always


#####  BELOW IS TO UPLOAD and install UCS BIG-IPs #####

  - name: Set the hostname of the BIG-IP
    bigip_hostname:
      hostname: "{{item.device}}"
      provider:
        server: "{{item.address}}"
        user: "{{user}}"
        password: "{{password}}"
        validate_certs: no
    delegate_to: localhost
    loop: "{{ targetDevices | dict2items }}"

  - name: Upload UCS
    bigip_ucs:
      ucs: "../ucs/{{item.fileName}}"
      state: installed
      passphrase: "{{password}}"
      provider:
        server: "{{item.address}}"
        user: "{{user}}"
        password: "{{password}}"
        validate_certs: no
    delegate_to: localhost
    ignore_errors: True
    loop: "{{ targetDevices | dict2items }}"

  # - name: Get status of device in BIG-IQ
  #   uri:
  #     url: "https://{{inventory_hostname}}/mgmt/shared/resolver/device-groups/cm-bigip-allBigIpDevices/devices/ba7382a4-7564-4647-b65d-17d6f2a73a16/stats"
  #     method: GET
  #     status_code: 200
  #     user: "{{user}}"
  #     password: "{{password}}"
  #     validate_certs: no
  #   delegate_to: localhost
  #   register: getStatusOnBigiq

  
  # - name: print debug
  #   debug:
  #     msg: "{{getStatusOnBigiq | json_query(query_json) }}"
  #   vars:
  #     query_json: >
  #       json.entries."health.summary".value


  # - name: POST - to load UCS
  #   uri:
  #     url: "https://{{bigipIP}}/mgmt/tm/sys/ucs"
  #     method: POST
  #     body: 
  #       command: load
  #       name: ansibleDeploy_202103010922_BOS-vBIGIP01.termmarc.com_ansibleDeploy_202103010922.ucs
  #     body_format: json
  #     status_code: 202,200
  #     user: "{{user}}"
  #     password: "{{password}}"
  #     validate_certs: no
  #     timeout: 120
  #   delegate_to: localhost
  #   register: returnOfUcsPost

  # - name: print results of POST of UCS
  #   debug:
  #     msg: "{{returnOfUcsPost}}"
    
######  BELOW IS TO RE-DISCOVER THE DEVICES AFTER RE-PAVE #####

  # - name: Collect BIG-IQ information
  #   bigiq_device_info:
  #     gather_subset:
  #       - vlans
  #     provider:
  #       user: "{{user}}"
  #       password: "{{password}}"
  #       server: "{{inventory_hostname}}"
  #       validate_certs: no
  #       #auth_provider: local
  #   delegate_to: localhost

  # - name: Re-discover device and import config, use default conflict policy.
  #   bigiq_device_discovery:
  #     device_address: "10.1.1.8"
  #     device_username: "{{user}}"
  #     device_password: "{{password}}"
  #     modules:
  #       - ltm
  #     force: yes
  #     access_group_name: boston
  #     access_conflict_policy: use_bigiq
  #     #access_conflict_policy: use_bigiq
  #     provider:
  #       password: "{{password}}"
  #       server: "{{inventory_hostname}}"
  #       user: "{{user}}"
  #       validate_certs: no
  #       #auth_provider: local
  #   delegate_to: localhost
